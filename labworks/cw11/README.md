# Лабораторная работа №1. Изучение основных инструкций ассемблера

## Цель работы

Приобрести навыки в отображении и понимании кодов ассемблера, полученных при разработке приложения на С++.

## Подготовка

Язык ассемблера - машинно-ориентированный язык программирования низкого уровня.
Это означает, что команды этого языка напрямую транслируются в машинный код (то есть команды, непосредственно выполняемые процессором).

В отличие от языков программирования высокого уровня (например, C, C++, C# и других), язык ассемблера является платформо-зависимым, то есть написанный на нём код жёстко привязан к конкретной архитектуре вычислительной системы.

Существует несколько наиболее популярных форматов записи команд процессора: Intel-синтаксис и AT&T-синтаксис.
Будем пользоваться Intel-синтаксисом как наиболее популярной формой записи языка ассемблера.

Для изучения основных инструкций процессора воспользуемся тем, что при компиляции программы на языке C++ для каждого исходного файла создаются объектные модули (файлы `*.o`), которые можно "дизассемблировать", то есть получить вид этого файла на языке ассемблера.

Современные среды разработки и утилиты позволяют просматривать преобразованные операторы с языка C++ на язык ассемблера достаточно просто.

Для Visual Studio достаточно в режиме отладки приложения нажать комбинацию клавиш `Ctrl + Alt + D`.

Для gcc/g++ (если кто-то использует linux или Code::Blocks с использованием именно gcc) получение такого же вывода доступно при использовании следующих команд терминала (в нашем случае текст программы лежит в файле _1.cpp_):

```bash
g++ -g -c 1.cpp
objdump -d -M intel -S 1.o 
```

В Visual Studio и в терминале в итоге должен получиться примерно такой вывод:

```asm
int main() {
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
        printf("Hello world!");
   4:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # b <main+0xb>
   b:   b8 00 00 00 00          mov    eax,0x0
  10:   e8 00 00 00 00          call   15 <main+0x15>
        return 0;
  15:   b8 00 00 00 00          mov    eax,0x0
}
  1a:   5d                      pop    rbp
  1b:   c3                      ret
```

## Разбор некоторых кодов

Скопируйте к себе и запустите следующую программу на языке C++:

```cpp
int main() {
	int x = 8;
	int y;
	y = x * x;
	if (y > 60) {
		return 1;
	} else {
		return 2;
	}
}
```

Если вы запустите программу, ничего не произойдёт (нет операций ввода-вывода).
Но это не означает, что ничего не происходит на самом деле.

Посмотрите на код метода `main`: там объявляются две целочисленные переменные `x` и `y`, присваивается переменной `x` значение 8, в переменную `y` записывается квадрат от переменной `x` (то есть _8*8=64_).
Затем, если значение в переменной `y` больше 60, программа завершается с кодом 1, иначе с кодом 2.

Если посмотреть на код ассембрела для этой программы, мы увидим примерно следующее:

```asm
0000000000000000 <main>:
int main() {
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
        int x = 8;
   4:   c7 45 f8 08 00 00 00    mov    DWORD PTR [rbp-0x8],0x8
        int y;
        y = x * x;
   b:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
   e:   0f af 45 f8             imul   eax,DWORD PTR [rbp-0x8]
  12:   89 45 fc                mov    DWORD PTR [rbp-0x4],eax
        if (y > 60) {
  15:   83 7d fc 3c             cmp    DWORD PTR [rbp-0x4],0x3c
  19:   7e 07                   jle    22 <main+0x22>
                return 1;
  1b:   b8 01 00 00 00          mov    eax,0x1
  20:   eb 05                   jmp    27 <main+0x27>
        } else {
                return 2;
  22:   b8 02 00 00 00          mov    eax,0x2
        }
}
  27:   5d                      pop    rbp
  28:   c3                      ret
```

На самом деле это не совсем код ассемблера: здесь смешаны строки на C++ (без `xx:` в начале. Они повторяют нашу программу) и их "расшифровка" в мнемониках (кодах) ассемблера (например, `1b:   b8 01 00 00 00          mov    eax,0x1`).

Сразу можно заметить, что некоторые команды C++ преобразуются в несколько команд ассемблера.
Например, команда `if (y > 60)` преобразуется сразу в команды `15: ...` и `19: ...`.
Номер в начале ассемблерной строки в данной случае - это номер байта от начала программы.

А бывает и наоборот, что код на C++ не преобразуется ни в одну ассемблерную команду.
Например, объявление переменной _y_ (`int y;`).
Дело тут в том, что в ассемблере нельзя объявлять свои переменные.
В каждом процессоре есть установленный заранее набор "переменных" - регистров, с которыми мы и можем работать.
Также есть возможность сохранять значения в стек.

> Вывод в Visual Studio будет слегка отличаться, однако многие элементы будут схожими.

Теперь рассмотрим коды ассемблера более внимательно.

В начале строки, как уже упоминалось ранее, содержится адрес нашей инструкции (ещё один синоним к "команде" и "коду" ассемблера) относительно начала программы в шестнадцатеричном виде.
То есть в одном разряде не 10 цифр, а 16: _1, 2, ..., 8, 9, A, B, C, D, E, F_.

> Запись чисел в шестнадцатиричном формате крайне популярна в информационных технологиях, т.к. при помощи двух 16-ричных чисел удобно записать значение байта (8 бит, а 16-ричное число описывает 4 бита).

Далее в строке следует запись инструкции в 16-ричном виде.
Например, `b8 02 00 00 00` для адреса `22:`.
Не будем сильно останавливаться на этом, тем более, что в выводе дизассемблера Visual Studio по умолчанию такой вывод отключен.

Далее в строке идёт собственно команда, которую мы говорим ассемблеру.
Примеры команд из программы выше: `push`, `mov`, `imul`, `cmp`, `jle`, `jmp`, `pop` и `ret`.

Команд на самом деле очень много, и в каждой архитектуре процессора их набор отличается.
Однако, в мире достаточно популярной является архитектура _x86_ от Intel.
Справочник по базовым командам этой архитектуры можно найти [здесь](http://www.club155.ru/x86cmdcpu).

После описания команды может идти набор аргументов.

Рассмотрим опять же команду по адресу 22: `mov    eax,0x2`.
Здесь происходит перемещение (_move_ или _mov_) числа 2<sub>16</sub> (в шестнадцатеричной системе счисления, т.к. в начале указано `0x`) в регистр общего назначения `eax`.
Заметьте, что приёмник в Intel-синтаксисе идёт перед источником.

Если проводить аналогию с C++, то мы бы записали что-то такое: `eax = 2;`.
То есть `eax` - это аналог переменной, а `mov` - аналог оператора присвоения `=`.

Иногда в качестве аргумента написано что-то наподобие `DWORD PTR [rbp-0x8]`.
Это означает, что значение длиной 32 бита (`DWORD` - 32 бита, "двойное слово") берётся из оперативной памяти по адресу (`PTR[..]` - pointer, указатель) из регистра `rbp` минус 8 байтов (`- 0x8`).
В нашей программе это аналог получения указателя к переменной _x_: `&x`.
Следует это понять и осознать.

Кстати, указаелем на адрес переменной _y_ будет являться запись `DWORD PTR [rbp-0x4]`.

Другой случай аргумента представлен в команде `jmp    27 <main+0x27>`.
Здесь наша программа "перепрыгивает" (`jmp` - jump, прыгнуть) на команду с адресом `0x27:`.
В треугольных скобках для удобства указано, к какой функции нашей программы относится эта инструкция: 27й байт от начала `main`.

## Задание на лабораторную работу

1. Набрать программу, указанную выше, в среде разработки: Visual Studio, Code::Blocks или любой другой. Запустить её.
2. Запустить режим дизассемблера. Получить вывод, похожий с тем, что представлен выше.
3. Рассмотреть и понять все команды ассемблера для всех операторов внутри `main()` кроме внешних фигурных скобок.
4. Скопировать программу ещё раз и изменить её согласно варианту, который Вам **выдал преподаватель**.
5. Также запустить для неё режим дизассемблера и рассмотреть новые команды.
6. Ответить на контрольные вопросы преподавателя.

## Варианты заданий

Правила модификации программы следующие:

* для вариантов с 1 по 7 вместо получения квадрата _x_ следует сделать сложение _x_ с номером вашего варианта;
* для вариантов с 8 по 15 вместо получения квадрата _x_ следует взять остаток от деления _x_ на номер варианта;
* для вариантов с 16 по 23 вместо получения квадрата _x_ следует сделать вычитание из _x_ числа, соответствующего номеру варианта;
* для вариантов с 24 по 30 вместо получения квадрата _x_ следует сделать деление _x_ на номер варианта.

* для вариантов с 1 по 10 следует вместо типа _int_ использовать _short_ (и понять отличие этих типов данных);
* для вариантов с 11 по 20 следует вместо типа _int_ использовать _char_ (и понять отличие этих типов данных);
* для вариантов с 21 по 30 следует вместо типа _int_ использовать _long_ (и понять отличие этих типов данных);

* для вариантов с 1 по 5, с 11 по 15 и с 21 по 25 в операторе _if_ вместо знака меньше следует использовать _меньше или равно_;
* для вариантов с 6 по 10, с 16 по 20 и с 26 по 30 в операторе _if_ вместо знака меньше следует использовать _больше_.

## Пример список контрольных вопросов

1. Для чего предназначена команда `...`?
2. Какие аргументы принимает команда `...`?
3. Что такое регистр общего назначения?
4. Что такое регистр флагов? Какие флаги оттуда можете вспомнить?
5. Почему программы для 64-разрядных ОС именуют как _x64_, а для 32-разрядных ОС - как _x86_?
6. Что означает _BYTE/WORD/DWORD/QWORD PTR_ в аргумнетах вашей программы?
7. Переведите число `0x...` в 10-ричную систему счисления?
8. Переведите число `...` в 16-ричную систему счисления?
