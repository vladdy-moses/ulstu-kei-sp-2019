# Лабораторная работа 5. Классы

## Цель работы

Изучить использование классов: основных элементов объектно-ориентированного программирования.

## Наш мир как набор объектов

Существует множество вариантов, как можно описать наш мир.

Представим, что всё в нашем мире состоит из каких-либо частей, которые мы будем называть **объектами**.
Например, стол состоит из ножек и столешницы, город состоит из улиц, площадей и отдельных домов, учебная группа состоит из студентов и т.д.

Если использовать формальный язык, то **объект** - это сущность, обладающая определённым состоянием и поведением.

Объекты со схожими признаками объединяются в **классы** объектов.
Например, класс `ЖилойДом` содержит объекты, в которых можно жить, а класс `Квадрат` содержит все плоские геометрические фигуры, у которых 4 равных стороны.

Вместо термина "объект" можно употреблять **экземпляр класса**.

Классы объектов (будем далее просто называть "классы") могут содержать **свойства** - то, что присуще всем экземплярам класса.
Например, у класса `Студент` могут быть свойства _Фамилия_, _Имя_, _Отчество_, _УчебнаяГруппа_.
У каждого студента будут эти свойства, причём у разных объектов значения свойств будут отличаться (хотя могут и совпадать, почему бы и нет).
Свойства могут быть абсолютно разными.
К примеру, при описании класса `УчебнаяГруппа` можно определить свойства _СтудентыГруппы_ и _СтаростаГруппы_, которые будет ссылаться на конкретные объекты класса `Студент`.

Также любой объект обладает каким-либо поведением.
Оно описывается через **методы** класса.
Методом класса является является процедура/функция (см. л/р 4), описанная в рамках определённого класса.
Например, описывая класс _Студент_, мы захотели, чтобы конкретный студент смог сказать, кто его староста (часто же преподаватели на первых занятиях спранивают у студентов: "Кто у вас староста?").
Мы описываем метод (то есть поведение) _ВерниФИОСтаросты_, в котором возвращается значение свойства _СтаростаГруппы_ у группы, которая является значением свойства _УчебнаяГруппа_ у экземпляра класса _Студент_, которого мы спросили.
Далее мы подробнее рассмотрим этот пример.

Здесь можно обратить внимание на то, что разделять объекты реального мира на классы и составные части можно по-разному.
Например, если мы хотим куда-то отправиться и используем общественный транспорт, то для программы расчёта маршрута будет достаточно указать конечную остановку.
Однако, если мы заказываем такси, таксисту необходимо знать дом и подъезд, куда вас необходимо доставить.
Один и тот же класс объектов `КонечнаяТочкаМаршрута` в данных случаях описывается совершенно по-разному.
Такие отличия всегда зависят от **предметной области**, то есть того, как представляются объекты реального мира для каждой конкретной задачи.

Ещё немного терминов:
* **инстанцирование класса** - создание экземпряла класса;
* **инициализация** - присвоение начальных значений свойствам объекта.

## Немного о заголовочных файлах

В лабораторной работе 4 мы уже знакомились с понятием прототипа процедуры/функции.

Для классов есть похожая конструкция:
* мы можем **объявить** структуру класса (_class declaration_);
* мы можем **определить** реализацию класса (_class definition_);

Сразу будем разделять объявление и определение класса, т.к. это в очередной раз будет напоминать о том, что другие разработчики при использовании вашего класса видят только его объявление, определение (реализация) класса от них скрыто.
Кстати, не только другие разработчики видят только объявление класса: даже внутри одной программы соседние классы видят только объявления своих соседей.

До этого весь код программ писался в файлах `.cpp` (или кто писал до этого на C, то `.c`).
Причём, зачастую только в одном файле `main.cpp`, т.к. этого было достаточно.

Объявления классов принято выделять в специальные "заголовочные" файлы (headers) с расширением `.h`.
Мы уже сталкивались с такими файлами, когда подключали математическую библиотеку (`#include <math.h>`).

Выводы:

* объявление (структуру) класса описывают в заголовочных файлах - `.h`
* реализацию класса описывают как раньше в файлах `.cpp`
* заголовочные файлы подключаются через `#include`

А теперь настало время описать свою "библиотеку".

## Создание первого класса

Создадим проект в любой IDE (на языке C++, конечно же).

Файл `main.cpp` будет примерно таким:

```cpp
#include <iostream>

using namespace std;

int main() {
    cout << "Test" << endl;
    return 0;
}
```

Создадим файл `Student.h`:

```cpp
#include <string> // для описания класса надо подключить библитеку для работы со строками

using namespace std; // чтобы не писать "std::string" везде.

class Student {
private:
    string firstName; // имя
    string middleName; // отчество
    string lastName; // фамилия
public:
    Student(string firstName, string middleName, string lastName); // инициализация класса
    string getFullName(); // вернуть ФИО
};
```

Как видно, мы описали класс `Студент`, в котором есть 3 свойства и два метода.

Заметьте, что свойсва находятся в группе _private_, что означает, что чужие классы не смогут получить к ним доступа.

Ещё интересно описание первого метода.
Можно заметить, что от обычной процедуры/функции его отличает отсутствие возвращаемого значение.
Также название метода совпадает с названием класса.
Такие метод называется **конструктором**.
Он позволяет производить инициализацию класса.

Хорошо, мы описали _объявление_ нашего класса.
Теперь мы можем использовать его в `main.cpp`:

```cpp
#include <iostream>
#include "Student.h"

using namespace std;

int main() {
    // создаём экземпляр класса Студент в памяти программы, проводим инициализацию
    Student* s = new Student("Имя", "Отчество", "Фамилия");
    
    // вызываем метод возврата ФИО и сразу пишем его в консоль
    cout << "Нашего студента зовут: " << s->getFullName() << endl;

    // освобождаем занятую ранее память
    delete s;

    // завершаем программу без ошибок
    return 0;
}
```

Заметитье, что при объявлении переменной `s` мы после названия класса использовали символ *.
Это означает, что в переменной `s` содержится не информация о конкретном экземпляре, а _место в памяти программы_, где находится эта информация о студенте.

> Кстати, обратная операция (получение адреса в памяти по имени переменное) - `&` использовалась ранее в операторе `scanf`.

Если сейчас запустить программу, то на этапе сборки возникнут ошибки:

```
/tmp/cctfABRh.o: In function `main':
main.cpp:(.text+0xc5): undefined reference to `Student::Student(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'
main.cpp:(.text+0x14c): undefined reference to `Student::getFullName[abi:cxx11]()'
collect2: error: ld returned 1 exit status
```

Означает примерно: "не знаю, где реализован конструктор и метод getFullName у класса Student".

А ведь и правда: мы объявили класс, но не написали его реализацию!

Создадим файл `Student.cpp`:

```cpp
#include "Student.h"

Student::Student(string firstName, string middleName, string lastName) {
    this->firstName = firstName;
    this->middleName = middleName;
    this->lastName = lastName;
}

string Student::getFullName() {
    string result = this->lastName + " " + this->firstName;
    if (this->middleName != "") {
        result += " " + this->middleName;
    }
    return result;
}
```

Сначала мы подключаем наше объявление класса (`#include "Student.h"`), затем пишем реализацию для наших методов.

Как видно, реализация конструктора очевидна: присвоение в свойства (ещё называют поля) класса значений фамилии, имени, отчества.

Реализация метода "верни ФИО" также нетрудная: возвращаем значение полей класса в порядке Фамилия, Имя, Отчество (при наличии).

## Создание второго класса

Мы описали класс `Студент`.
Теперь опишем класс `УчебнаяГруппа`.

У группы есть свойства: номер курса, название, староста.

Файл `Group.h`:

```cpp
#include <string>

class Student; // указываем, что нам понадобится класс Студент

using namespace std;

class Group {
private:
    string name; // название
    int form; // курс
    Student* head; // староста
public:
    Group(string name, int form); // инициализация класса (заметьте, без указания старосты)
    void setHead(Student* s); // задать старосту группы
    Student* getHead(); // вернуть старосту группы
};
```

Файл `Group.cpp`:

```cpp
#include "Group.h"
// уже не надо писать #include "Student.h", т.к. это есть в файле Group.h

Group::Group(string name, int form) {
    this->name = name;
    this->form = form;
}

void Group::setHead(Student* s) {
    this->head = s;
}

Student* Group::getHead() {
    return this->head;
}
```

Отличительная особенность от первого класса состоит в том, что мы инициировали в конструкторе не все свойства.

Для свойства head (староста) мы написали set- и get- методы.
Они обычно называются "сеттер" и "геттер".
Хорошая практика "оборачивать" доступ к свойствам в сеттеры и геттеры: то есть само поле класса делать приватным, а такие методы публичными.

Добавим в заголовок файла `Student.h` описание нового поля и новых методов "задай группу у студента" и "верни ФИО старосты":

```cpp
#include <string> // для описания класса надо подключить библитеку для работы со строками

class Group; // NEW: указываем, что нам понадобится класс УчебнаяГруппа

using namespace std; // чтобы не писать "std::string" везде.

class Student {
private:
    string firstName; // имя
    string middleName; // отчество
    string lastName; // фамилия
    Group* group; // NEW: учебная группа
public:
    Student(string firstName, string middleName, string lastName); // инициализация класса
    string getFullName(); // вернуть ФИО
    void setGroup(Group* group); // NEW: задать группу
    string getGroupHeadFullName(); // NEW: вернуть ФИО старосты
};
```

Реализация класса студент теперь выглядит следующим образом:

```cpp
#include "Student.h"
#include "Group.h" // NEW

Student::Student(string firstName, string middleName, string lastName) {
    this->firstName = firstName;
    this->middleName = middleName;
    this->lastName = lastName;
}

string Student::getFullName() {
    string result = this->lastName + " " + this->firstName;
    if (this->middleName != "") {
        result += " " + this->middleName;
    }
    return result;
}

// NEW
void Student::setGroup(Group* group) {
    this->group = group;
}

// NEW
string Student::getGroupHeadFullName() {
    return this->group->getHead()->getFullName();
}
```

Немного изменим метод _main_ в файле `main.cpp`: создадим больше студентов, определим их в одну группу и укажем одного старостой:

```cpp
#include <iostream>
#include "Student.h"
#include "Group.h"

using namespace std;

int main() {
    // определяем студентов
    Student* s1 = new Student("Имя1", "Отчество1", "Фамилия1");
    Student* s2 = new Student("Имя2", "Отчество2", "Фамилия2");
    
    cout << "Студент1: " << s1->getFullName() << endl;
    cout << "Студент2: " << s2->getFullName() << endl;

    // определяем группу
    Group* g = new Group("ИСТбд-21", 2);
    
    // прикрепляем студентов к группе
    s1->setGroup(g);
    s2->setGroup(g);

    // определяем старосту
    g->setHead(s2);

    // выводим старосту у студента s1
    cout << "Староста группы: " << s1->getGroupHeadFullName() << endl;

    // освобождаем занятую ранее память
    delete s1, s2, g;

    // завершаем программу без ошибок
    return 0;
}
```

Как видно, мы указали старостой второго студента, а спросили "кто староста?" у первого.
Тем не менее, программа вернула ФИО второго студента.

## Задание

Необходимо разработать программу на языке C++, в которой будет определено и реализовано два класса из варианта задания.

Во первом классе необходимо добавить свойство, которое указывало бы на экземпляр второго класса.
При этом у класса должен быть хотя бы один метод, который бы возвращал данные второго класса.
Пример: класс `Student`.

Во втором классе необходимо описать от 2х свойств, причём некоторые (или все) необходимо задавать при помощи конструктора класса.
Пример: класс `Group`.

В процедуре _main()_ необходимо создать несколько экземпляров разных классов, связать их друг с другом (через свойства) и продемонстрировать, что эта связь работает.

> Классы для примеров подбирались по принципу _ОбъектКласса1_ находится в собственности у _ОбъектаКласса2_.
> Эту связь и можно реализовать.

## Варианты заданий

| Вариант | Класс 1    | Класс 2            |
| ------- | ---------- | ------------------ |
| 1       | Автомобиль | Студент            |
| 2       | Телефон    | Студент            |
| 3       | Компьютер  | Студент            |
| 4       | Стол       | Аудитория          |
| 5       | Стул       | Аудитория          |
| 6       | Квартира   | Студент            |
| 7       | Дом        | Рабочий            |
| 8       | Аудитория  | Кафедра            |
| 9       | Проездной  | Студент            |
| 10      | Автомобиль | Рабочий            |
| 11      | Компьютер  | Аудитория          |
| 12      | Телефон    | Рабочий            |
| 13      | Компьютер  | Рабочий            |
| 14      | Кафедра    | Университет        |
| 15      | Ноутбук    | Рабочий            |
| 16      | Ноутбук    | Студент            |
| 17      | Веб-сайт   | ИТ-компания        |
| 18      | Доска      | Аудитория          |
| 19      | Учебник    | Студент            |
| 20      | Альбом     | Музыкальная группа |
| 21      | Музыкант   | Музыкальная группа |
| 22      | Аудитория  | Университет        |
| 23      | Квартира   | Рабочий            |
| 24      | Проездной  | Рабочий            |
| 25      | Автомобиль | Университет        |
| 26      | Компьютер  | Кафедра            |
| 27      | Ноутбук    | Кафедра            |
| 28      | Учебник    | Университет        |
| 29      | Корпус     | Университет        |
| 30      | Ноутбук    | Аудитория          |

> Подбирайте названия классов на английском языке.

> Также название связующего свойства не всегда очевидно.
> Например, если автомобилем вледеет студент, то у автомобиля свойство должно называться _Owner_, не _Student_.

## Ссылки

* [Лабораторная работа №4](../cw04/README.md)
* [Лабораторная работа №6](../cw06/README.md)

