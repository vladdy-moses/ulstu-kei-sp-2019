# Лабораторная работа 7. Указатели

## Цель работы

Изучить основные принципы использования указателей в языках C/C++.

## На что указывают "указатели"?

Задумывались ли вы, где хранятся все те значения переменных, которые мы храним при работе наших программ?

Не зря в компьютерах есть понятие "оперативной памяти": это такая память, которая является быстрой (намного быстрее жёстких дисков) и удобной для работы процессора (физическое устройство ОЗУ относительно простое).
Также оперативная память является энергозависимой, то есть при потере питания все данные из неё стираются.

Идеальное место, чтобы в ней хранились наши "переменные" - само это слово указывает на временность записанной в переменных информации.

Итак, все данные, необходимые для работы программ (то есть значения переменных, в т.ч. массивов и других структур данных) хранятся в оперативной памяти.

> Многие на этом этапе могут сказать, что в современных операционных системах есть такое понятие как "виртуальная память", но для понимания указателей этого не требуется.

Есть немного упростить, то оперативная память представляет из себя набор ячеек по одному байту, пронумерованных от 0 до `огромноеЗначение`.
Например, для памяти в 4 гигабайта номера ячеек будут от 0 до 4294967295.
И в каждом байте (то есть в каждой ячейке) могут быть сохранены данные для наших программ.

> Кстати, такие огромные объёмы памяти были не всегда.
> Биллу Гейтсу приписывают фразу, что "640 Кб памяти хватит на всех".
> Сейчас это кажется смешным, но раньше такой огромный объём памяти действительно поражал.

Вернёмся к вопросу этого раздела: что такое "указатель" и на что он указывает?

**Указатель** - переменная специального типа, которая хранит **адрес в области памяти**.

Если обычные переменные хранят данные (int - целые числа, char - сиволы, float - дробные числа и т.д.), то указатель хранит ссылку на адрес памяти.

Обозначаются указатели через символ `*`:

```cpp
int i;   // объявление обычной целочисленной переменной
int *j;  // объявление указателя на адрес в памяти, где лежит какое-то число
int* r;  // ...это тоже указатель
int * k; // ...и это указатель
```

## Связь указетелей и обычных переменных

Как думаете, можно ли по названию переменной получить адрес в памяти, по которому лежит значение этой переменной?

Допустим, мы объявили переменную и присвоили ей значение:

```cpp
int i;
i = 5;
```

Можно ли найти указатель на область памяти, где хранится значение переменной `i`?

Можно!

```cpp
int *i_ptr = &i; // символ & перед названием переменной возвращает её адрес в памяти
```

> Кстати, указатель по-английски - _pointer_ (или кратко _ptr_).

Получение по названию переменной её адреса в памяти называется **операцией получения адреса** и обозначается в C/C++ символом `&`.

Вы могли уже видеть этот символ при использовании `scanf` в первых лабораторных работах.
Можете сейчас вернуться и осознать, зачем он там нужен.

Другой вопрос: а можно ли из указателя на память получить значение, которое там лежит?
То есть действие, обратное процессу получения адреса.

Можно!
Рассмотрим следующий относительно странный пример:

```cpp
int i = 5; // объявляем переменную и присваиваем ей значение
int *i_ptr = &i; // объявляем указатель и присваем ему значение (это уже было)
*i_ptr = 1; // ВНИМАНИЕ! Мы присваиваем по адресу i_ptr значение 1
printf("i = %d \n", i); // вернётся 1, а не 5
```

Почему в примере на экран вывелось 1, а не 5, хотя мы не трогали переменную `i`?

Всё довольно логично: мы внесли число 1 _напрямую в области памяти_, где лежит значение переменной `i`.

Получение содержимого по указателю в памяти называется **оператором разыменования** и обозначается в C/C++ символом `*`.

## Размер переменных в памяти

Для записи различных типов данных в памяти требуется различное количество байт.

Для того, чтобы узнать, сколько байт нужно, например, для записи чисел, можно использовать следующий код:

```cpp
printf("sizeof(int) = %ld \n", sizeof(int)); // sizeof(int) возвращает размер памяти в байтах для хранения целых чисел
```

## Задание

В данной лабораторной работе **нет чётко описанных вариантов**.

Шаги выполнения:

1. Напишите программу, которая выводит на экран размер в байтах для трёх различных типов из: _char, byte, short, int, long, float, double и т.д._
2. Дополните программу, чтобы она выводила на экран размер (в байтах) переменной-указателя на целое число, на дробное число.
3. Рассчитайте, сколько различных ячеек памяти можно описать при помощи количества байт, найденного в п.2. Например, в 1 байт можно записать 256 различных чисел. Для ответа лучше использовать степени двойки.
4. Если каждая ячейка памяти - 1 байт, сколько гигабайт (терабайт, петабайт, эксабайт и.т.д.) памяти максимально можно описать через указатель, найденный в п.2? Для расчёта можно или дополнить программу, или произвести расчёт вручную.
5. Сделайте аналогичный расчёт для системы, где указатель (п.2) описывается 4 байтами.
6. В качестве аргумента для `sizeof` можно указывать не только типы данных, но и названия объявленных переменных. Дополните вашу программу примером с указателями (был ранее) и выведите на экран размер переменных `i` и `i_ptr`. 

## Ссылки

* [Лабораторная работа №6](../cw06/README.md)
* [Лабораторная работа №8](../cw08/README.md)
